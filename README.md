# Fluid

# Взаимодействие с программой:

Удерживание правой кнопки мыши - отталкивание частиц от точки, на которую указывает мышка
Удерживание левой кнопки мыши - притягивании частиц от точки, на которую указывает мышка

При удержании любой из них можно регулировать силы, которую мы прилагаем на частицы.
При этом если сильно повысить (понизить), то частицы начнут притягиваться (отталкиваться), а не отталкиваться (притягиваться)


# Структура проекта:
    - shaders (Папка с шейдарами)
        - fragment.shader
        - vertex.shader

    - vendors (папка с библиотеками)
        - glm
        - glew
        - sdl
        
    - src
        - Debug (содержит необходимый для дебага программы. К примеру Таймер)
        - Graphics (содержит функции отвечающие за работу графики)
        - math (содержит некоторые функции и типы необходимые для работы программы)
        - NearestNeighborSearch (содержит типы и функции, которые необходимы для реализации алгоритма Nearest Neightbor Search)
        - PBF (модуль в котором находится реализация алгоритма)
        - main.cpp (точка старта программы)
        - settings.hpp (настройки программы)

# Структура файла main.cpp

int main() - начальная точка</br></br>
void Update(GLuint&, GLuint&, GLint&) - функция, которая вызывается каждый фрейм. Она отвечает за обновление экрана и значений позиций частиц. В ней происходит вся работа</br></br>
void MainLoop(SDL_Window*, SDL_GLContext&, GLuint&) - функция, которая содержит главный цикл программы и начальные инициализации некоторых значений</br></br>
void Input(bool& quit) - функция, в которой происходит обработка входящих сигналов: закрытие окна и работа с мышкой</br>

# Структура файла settings.hpp

scalar - является либо float, либо double. В зависимости от точности, которую хочешь

WWIDTH - ширина экрана
WHEIGHT - высота экрана

BOXWIDTH - ширина коробки, в которой находятся все частицы (то есть определяет где могут находится частицы на экране, чтобы они не выходили за его пределы)</br>
BOXHEIGHT - высота коробки

BOXMARGINX - отступ от правой и левой границы окна до коробки</br>
BOXMARGINY - отступ от верхней и нижней границы окна до коробки

PARTICLES_NUMBER - определяет количество частиц

scale - коэффицент для уменьшения координат или увеличения (чтобы допустим сделать так чтобы координаты всего эркана преобразовывались к виду от 0 до 1)</br>
area - площадь на окне, которую занимает каждый квадрат необходимый для алгоритма NearestNeighborSearch

influenceRadius - радиус, внутри которого частица влияет на значение плотности</br>
radius - радиус частицы (визуальный)

interactionInputRadius - опредляет в каком радиус силы, с которой пользователь может взаимодействовать с частицами

mass - масса частицы</br>
targetDensity - плотность, к которой мы стремимся

threads - количество потоков (только параллельная версия)

# NearestNeighborSearch

в картинке NNS_explain можно увидеть сетку на которую делится вся коробка. Каждый квадрат имеют площадь area
Красным нарисована частица. А желтая - области в которых будет производится поиск частиц. Это помогает избежать просмотра всех частиц, которые есть
а рассматривать только что близко.

Так как area - фиксированная. То нет необходимости использовать malloc. Мы создаем сразу массив этих сегментов. Каждый сегмент представляет собой связанный список.
Он содержит значение индекса частицы и другой частицы, которая есть в этой области. Такая организация позволяет легко хранить динамическое количество частиц в одном
сегменте (то есть таким образом область может содержать от 0 до n частиц)

# структура файла Particles (находится в папке PBF)

Particle - структура которая содержит вектор скорости частицы и ее координаты</br>
Particles - структура, которая содержит все частицы (data orientated programming)

Каждая структура выровнена по 8 byte (alignas(64)), что позволяет избежать проблемы с false sharing при распараллеливовании

lambdas - массив лябмд, используемый для вычисления вектора движения частиц в алгоритме</br>
interactionInputStrength - сила, с которой действует пользователь на частицы</br>
interactionInputPoint - место нажатия (и соответственно приложения силы)

void newUpdateSegment(const int& i, const int& pre, const int& post) - фунцию на замену старой версии. Необходима для того, чтобы обновлять локацию частицы в алгоритме NearestNeighborSearch
    
void collisionResponse(const vec2& pos, const int& Index) - создает обратную силу взимодействия частиц с стенками</br>
void boundaryCondition(const int& Index, vec2& dp) - ограничивает расположение частиц</br>
void collisionHandler(const int& Index, vec2& dp) - Функция, объединяющая две верхнии

void particlesUpdate() - здесь происходит работа алгоритма</br>
void initParticles() - задаются начальные значения частиц и также распределяются по сегментам</br>
void distribute() - функция распределения частиц по сегментам. Вызывается только в initParticles.

void sort() (deprecated) - параллельная сортировка
void calcLambda(const int& Index) - фукнция которая считает значение лямбды для частицы с индексом Index

vec2 calcDeltaPosition(const int& Index) - высчитывает вектор скорости для частицы (то есть считает куда должна двигаться частицы чтобы сохрнать равномерную плотность)</br>
vec2 calcGradient(const int& Index, const int& k) - считает градиент функции calcPoly6 (которая считает плотность)</br>
vec2 calcVorticityAndViscosity(const int& Index) - считается vorticity и вязкость</br>
vec2 ExternalForces(const vec2& pos, const vec2& velocity) - считаются силы, которые идут от взаимодействия пользователя и жидкости

Более подробно алгоритм написан в статье Position Based Fluids 2013

Во многих функция есть похожий паттерн кода:
```
const unsigned segInd = GetSegmentIndex(prediction[Index]);
for (int locShift = 0; locShift < 9; locShift++)
{
	const int location = GetLocationFromShift(segInd, locShift);
	if (location < 0) continue;

	for (Node* seg = segments.segments[location]; seg; seg = seg->next)
	{
			// работает алгоритм
	}
}
```
Это применение алгоритма NearestNeighborSearch. В первой строичке GetSegmentIndex возвращает индекс сегмента, в котором находится частица с id Index
После этого надо осмотреть 9 клеток (вокруг и та, в которой частица находится). GetLocationFromShift - функция которая и возвращает индекс сегмента, который
будет осматриваться следующем. Эта функция учитывает ситуации, когда индексы выходит за границы массива сегментов и возвращает -1 в этом случае.</br>
В строичке for (Node* seg = segments.segments[location]; seg; seg = seg->next) мы проходимся по всем частицам в сегменте с индексом location

## Описание констант:
    
- coeff - константа на которую надо домнажать чтобы получить координаты с учтением scale
- epsilon - супер маленькая константа, используется для вычитывания производных
- dt. Время в программе дискретное. Dt - определяет промежуток времени, на которое мы его разбиваем
- resistance - коэффицент который определяет потерю силы от действия стороних сил (трения, сопротивление)
- gravity - сила гравитации
- viscosity_c - коэффицент который определяет с какой силой действует вязкость за частицы
- relaxation - параметр который помогает избавиться от деления на 0, а также избежать от слишком маленьких чисел
- delta_q, tensible_instability_k, tensible_instability_n - параметры из алгоритма
- collision_penalty - коэффицент который определяет насколько сильно частица оттолкнется от препятствия
- iterations - параметр необходимый для более точной симуляции

- prediction[PARTICLES_NUMBER] - следующее положение частиц
- external[PARTICLES_NUMBER] - влияние сил, на каждую из частиц